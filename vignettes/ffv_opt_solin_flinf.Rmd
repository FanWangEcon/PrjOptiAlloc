---
title: Linear (CRS) Optimal Allocation Solution (Function)
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Linear (CRS) Optimal Allocation Solution (Function)}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
urlcolor: blue
---

Back to **[Fan](https://fanwangecon.github.io/)**'s Optimal Allocation Homepage **[Table of Content](https://fanwangecon.github.io/PrjOptiAlloc/)**

There are two related filed:

1. *vignettes\ffv_opt_solin_flinf.Rmd*

# Outline

This is the function based file for

## Set Up

```{r GlobalOptions, echo = T, results = 'hide', message=F, warning=F}
rm(list = ls(all.names = TRUE))
options(knitr.duplicate.label = 'allow')
```
```{r loadlib, echo = T, results = 'hide', message=F, warning=F}
library(dplyr)
library(tidyr)
library(stringr)
library(broom)
library(ggplot2)
library(R4Econ)

library(PrjOptiAlloc)

library(knitr)
library(kableExtra)
```

## Get Data and Regression Results

Generate four categories by initial height and mother's education levels combinations.

```{r Load Packages and Process Data}
# Load Data and Estimation Results: A and alpha, lin and loglin
ls_opti_alpha_A <- ffy_opt_dtgch_cbem4()
df_raw <- ls_opti_alpha_A$df_raw
df_hw_cebu_m24 <- df_raw
df_esti <- ls_opti_alpha_A$df_esti

# Review dataframes
# raw file
head(df_raw, 10)
head(df_esti, 10)

# Attach
attach(df_raw)
```

## Rename Results Use Linear

To replicate previous results, rename linear A and alpha for optimal allocation. 

```{r Post Regression Input Processing}
# Initate Dataframe that will store all estimates and optimal allocation relevant information
tb_opti <- as_tibble(df_esti) %>% 
            select(alpha_lin, A_lin, beta) %>%
            rename(alpha = alpha_lin, A = A_lin, beta = beta)

# Print
head(tb_opti, 10)
```

# Optimal Allocations

## Common Parameters for Optimal Allocation

```{r Set Allocation Parameters}
# Child Count
df_hw_cebu_m24_full <- df_hw_cebu_m24
it_obs = dim(df_hw_cebu_m24)[1]

# Total Resource Count
ar_prot_data = df_hw_cebu_m24$prot
fl_N_agg = sum(ar_prot_data)

# Vector of Planner Preference
ar_rho = c(seq(-200, -100, length.out=5), seq(-100, -25, length.out=5), seq(-25, -5, length.out=5), seq(-5, -1, length.out=5), seq(-1, -0.01, length.out=5), seq(0.01, 0.25, length.out=5), seq(0.25, 0.99, length.out=5))
ar_rho = c(-50, -25, -10)
ar_rho = unique(ar_rho)
```

## Optimal Linear Allocation (CRS)

This also works with any CRS CES.

### Optimal Linear Allocation Hard-Coded

```{r Optimal Linear Allocation Hard Code All Rho}
# Optimal Linear Equation
# Planner Inputs
mt_hev_lin = matrix(, nrow = length(ar_rho), ncol = 2)
mt_opti_N = matrix(, nrow = it_obs, ncol = length(ar_rho))

# A. First Loop over Planner Preference
# Generate Rank Order
for (it_rho_ctr in seq(1,length(ar_rho))) {
  rho = ar_rho[it_rho_ctr]

  # B. Generate V4, Rank Index Value, rho specific
  # tb_opti <- tb_opti %>% mutate(!!paste0('rv_', it_rho_ctr) := A/((alpha*beta))^(1/(1-rho)))
  tb_opti <- tb_opti %>% mutate(rank_val = A/((alpha*beta))^(1/(1-rho)))

  # c. Generate Rank Index
  tb_opti <- tb_opti %>% arrange(rank_val) %>% mutate(rank_idx = row_number())

  # d. Populate lowest index alpha, beta, and A to all rows
  tb_opti <- tb_opti %>% mutate(lowest_rank_A = A[rank_idx==1]) %>%
                mutate(lowest_rank_alpha = alpha[rank_idx==1]) %>%
                mutate(lowest_rank_beta = beta[rank_idx==1])

  # e. relative slope and relative intercept with respect to lowest index
  tb_opti <- tb_opti %>%
                mutate(rela_slope_to_lowest =
                         (((lowest_rank_alpha*lowest_rank_beta)/(alpha*beta))^(1/(rho-1))*(lowest_rank_alpha/alpha))
                      ) %>%
                mutate(rela_intercept_to_lowest =
                         ((((lowest_rank_alpha*lowest_rank_beta)/(alpha*beta))^(1/(rho-1))*(lowest_rank_A/alpha)) - (A/alpha))
                      )

  # f. cumulative sums
  tb_opti <- tb_opti %>%
                mutate(rela_slope_to_lowest_cumsum =
                         cumsum(rela_slope_to_lowest)
                      ) %>%
                mutate(rela_intercept_to_lowest_cumsum =
                         cumsum(rela_intercept_to_lowest)
                      )

  # g. inverting cumulative slopes and intercepts
  tb_opti <- tb_opti %>%
                mutate(rela_slope_to_lowest_cumsum_invert =
                         (1/rela_slope_to_lowest_cumsum)
                      ) %>%
                mutate(rela_intercept_to_lowest_cumsum_invert =
                         ((-1)*(rela_intercept_to_lowest_cumsum)/(rela_slope_to_lowest_cumsum))
                      )

  # h. Relative x-intercept points
  tb_opti <- tb_opti %>%
                mutate(rela_x_intercept =
                         (-1)*(rela_intercept_to_lowest/rela_slope_to_lowest)
                      )

  # i. Inverted relative x-intercepts
  tb_opti <- tb_opti %>%
                mutate(opti_lowest_spline_knots =
                         (rela_intercept_to_lowest_cumsum + rela_slope_to_lowest_cumsum*rela_x_intercept)
                      )

  # j. Sort by order of receiving transfers/subsidies
  tb_opti <- tb_opti %>% arrange(rela_x_intercept)

  # k. Find position of subsidy
  tb_opti <- tb_opti %>% arrange(opti_lowest_spline_knots) %>%
                mutate(tot_devi = opti_lowest_spline_knots - fl_N_agg) %>%
                arrange((-1)*case_when(tot_devi < 0 ~ tot_devi)) %>%
                mutate(allocate_lowest =
                         case_when(row_number() == 1 ~
                                     rela_intercept_to_lowest_cumsum_invert +
                                     rela_slope_to_lowest_cumsum_invert*fl_N_agg)) %>%
                mutate(allocate_lowest = allocate_lowest[row_number() == 1]) %>%
                mutate(opti_allocate =
                         rela_intercept_to_lowest +
                         rela_slope_to_lowest*allocate_lowest) %>%
                mutate(opti_allocate =
                         case_when(opti_allocate >= 0 ~ opti_allocate)) %>%
                mutate(opti_allocate_total = sum(opti_allocate, na.rm=TRUE))

  # l. Summarize outputs
  tb_opti_main_results <- tb_opti %>% 
    select(-one_of(c('lowest_rank_alpha', 'lowest_rank_beta')))
  
  print('')
  print('xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx')
  print(paste0('xxx rho:', rho))
  print('xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx')
  print('xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx')

  print(summary(tb_opti_main_results))
  
}

# lineplot <- tb_opti %>%
#     gather(variable, value, -month) %>%
#     ggplot(aes(x=month, y=value, colour=variable, linetype=variable)) +
#         geom_line() +
#         geom_point() +
#         labs(title = 'Mean and SD of Temperature Acorss US Cities',
#              x = 'Months',
#              y = 'Temperature in Fahrenheit',
#              caption = 'Temperature data 2017') +
#         scale_x_continuous(labels = as.character(df_temp_mth_summ$month),
#                            breaks = df_temp_mth_summ$month)

```

