---
title: BINARY--NSW Training WAGE and EMPLOYMENT Optimal Allocation Analysis
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{BINARY--NSW Training WAGE and EMPLOYMENT Optimal Allocation Analysis}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
urlcolor: blue
---

Back to **[Fan](https://fanwangecon.github.io/)**'s Optimal Allocation Homepage **[Table of Content](https://fanwangecon.github.io/PrjOptiAllo==c/)**

# Objective

Test binary allocation queue with Lalonde training dataset. There are 722 observations, 297 in the treatment group, 425 in the control group.

Already completed optimal ranking analysis and regressions for [wage](https://fanwangecon.github.io/PrjOptiAlloc/articles/ffv_opt_sobin_rkone_allfc_training_wage.html) and [employment](https://fanwangecon.github.io/PrjOptiAlloc/articles/ffv_opt_sobin_rkone_allfc_training_logit.html). Here, I combine the results together and generate some joint graphs analyzing:

1. The relationship between expected probability of employment and wage ($A_i$) without training, and the expected return to training for employment and wage ($\alpha_i$).
2. For each individual, does their optimal allocation ranking change under the Rawlsian to Utilitarian planner? For wage vs employment based rankings
3. Who are those ranked in top 10 to receive? Along the spectrum
4. Resource Equivalent Variation along the spectrum

# Load Packages and Data

## Load Dependencies

```{r GlobalOptions, echo = T, results = 'hide', message=F, warning=F}
rm(list = ls(all.names = TRUE))
options(knitr.duplicate.label = 'allow')
```
```{r loadlib, echo = T, results = 'hide', message=F, warning=F}
library(dplyr)
library(tidyr)
library(tibble)
library(purrr)
library(stringr)
library(broom)
library(ggplot2)
library(REconTools)

library(PrjOptiAlloc)

library(knitr)
library(kableExtra)
```

## Merge the Wage and Employmennt Rsults

Generate four categories by initial height and mother's education levels combinations.

```{r Load Packages and Process Data}
# Load Data
data(df_opt_lalonde_training_employ)
data(df_opt_lalonde_training_wage)

# dfj, dataframe joint
dfj <- df_opt_lalonde_training_employ %>% left_join(df_opt_lalonde_training_wage, by = 'id')

# drop the .y variables, clean the .x out
dfj <- dfj %>% select(-contains(".y")) %>% 
          rename_at(vars(ends_with(".x")), funs(str_replace(., ".x", "")))

# order and organize variables
dfj <- dfj %>% select(id, 
                      starts_with("A_"), starts_with("alpha_"), starts_with("beta_"),
                      contains("rank"), contains("rho"), 
                      everything())

# Summarize
str(dfj)
summary(dfj)
```

# Analysis of A and alpha

Generate some tables where the distributions of $A$ and $\alpha$ are compared. 

## Scatter Plots

```{r}
# Binary Marginal Effects and Prediction without Binary
ggplot.A.alpha <- function(df, svr_alpha = 'alpha_i', svr_A = "A_i",
                             slb_title = 'A_i and alpha_i (red)'){
  scatter <- ggplot(df, aes(x=!!sym(svr_A))) +
        geom_point(aes(y=!!sym(svr_alpha)), size=4, shape=4, color="red") +
        labs(title = paste0(slb_title),
             x = 'A_i',
             y = 'alpha_i',
             caption = paste0('sdt_name')) +
        theme_bw()
return(scatter)
}

# Plot over multiple
ggplot.A.alpha(df = dfj, 
               svr_alpha = 'alpha_i_wage', svr_A = "A_i_wage",
               slb_title = 'A_i and alpha_i, wage')

ggplot.A.alpha(df = dfj, 
               svr_alpha = 'alpha_i_employ', svr_A = "A_i_employ",
               slb_title = 'A_i and alpha_i, employment')

```

## Histogram Plots

What is the distribution of A given alpha. This is relevant in the linear regression case
```{r}
# Keep only relevant columns, and reshape data
dfj_hist <- dfj %>% select(id, A_i_wage, alpha_i_wage)
dfj_hist$alpha_i_wage <- factor(dfj_hist$alpha_i_wage) 
# dfj_hist$alpha_i_wage <- factor(dfj_hist$alpha_i_wage, labels = c('ECON', 'Not.Econ'))

# Graph 
dfj_hist %>% ggplot(aes(x=A_i_wage, fill=alpha_i_wage)) +
      geom_density( color="#e9ecef", alpha=0.6, position = 'identity') +
      scale_fill_manual(values=c("#69b3a2", "#404080")) +
      labs(fill="")
```


# Min and Max Rank Change Across Lambda

The max calculated by ffp_opt_anlyz_rhgin_bin is the top rank, small in number. The min calculated by the function is the lowest ranked, largest number. 

## Histogram Plots and Table highest Rank Reached

Looked highest rank reached for each (highest rank (smallest number ever reached)).

```{r}
# Generate min and max gaps
dfj_highest <- dfj %>% select(id, rank_max_wage, rank_max_employ)

# Wide to long
st_gap_prefix <- 'rank_max'
dfj_highest_long <- dfj_highest %>%
  pivot_longer(
    cols = starts_with(st_gap_prefix),
    names_to = c('employvswwage'),
    names_pattern = paste0(st_gap_prefix, "_(.*)"),
    values_to = 'highestrank'
  )

# Rank change to categories
dfj_highest_long <- dfj_highest_long %>%
           mutate(highestrank_grp =
                    case_when(highestrank == 1 ~ "Top A 1",
                              highestrank <= 10  & highestrank > 1 ~ "Top B 10",
                              highestrank <= 50 & highestrank > 10 ~ "Top C 11 to 50",
                              highestrank <= 100 & highestrank > 50 ~ "Top D 51 to 100",
                              highestrank <= 297 & highestrank > 100 ~ "Top E 101 to 297",
                              highestrank > 297 ~ "Top F > 297"))

# Graph 
dfj_highest_long %>% ggplot(aes(x=highestrank, fill=employvswwage)) +
      geom_histogram(color="#e9ecef", alpha=0.6, position = 'identity') +
      scale_fill_manual(values=c("#69b3a2", "#404080")) +
      labs(fill="")

# Table
dfj_highest_long %>% group_by(employvswwage, highestrank_grp) %>% 
                summarize(count = n())
```

## Histogram Plots and Table Mand and Max Change

From the wage and employment analysis, each generates min and max rank

1. generate rank min max gap for wage and employment: min minus max because min number is actually the larger number (lower rank)
2. reshape wide to long, gap one variable, wage vs employment categorical
3. show table summary statistics differences
4. show graph differences

```{r}
# Generate min and max gaps
dfj_gap <- dfj %>% mutate(rank_gap_wage = rank_min_wage - rank_max_wage,
                          rank_gap_employ = rank_min_employ - rank_max_employ) %>%
                select(id, rank_gap_wage, rank_gap_employ)

# Wide to long
st_gap_prefix <- 'rank_gap'
dfj_gap_long <- dfj_gap %>%
  pivot_longer(
    cols = starts_with(st_gap_prefix),
    names_to = c('employvswwage'),
    names_pattern = paste0(st_gap_prefix, "_(.*)"),
    values_to = 'rank_gap'
  )

# Rank change to categories
dfj_gap_long <- dfj_gap_long %>%
           mutate(rank_gap_grp =
                    case_when(rank_gap == 0 ~ "change A no change",
                              rank_gap <= 50  & rank_gap > 0 ~ "change B 50 positions",
                              rank_gap <= 100 & rank_gap > 50 ~ "change C 51 to 100",
                              rank_gap <= 200 & rank_gap > 100 ~ "change D 101 to 200",
                              rank_gap <= 400 & rank_gap > 200 ~ "change E 201 to 400",
                              rank_gap > 400 ~ "change F more than 401"))

# Graph 
dfj_gap_long %>% ggplot(aes(x=rank_gap, fill=employvswwage)) +
      geom_histogram(color="#e9ecef", alpha=0.6, position = 'identity') +
      scale_fill_manual(values=c("#69b3a2", "#404080")) +
      labs(fill="")

# Table
dfj_gap_long %>% group_by(employvswwage, rank_gap_grp) %>% 
                summarize(count = n())
```


# Table of Top 10 Individuals

```{r top 10 ranked at least once}

# Calculat the maximum rank reached by each from all the rhos we have
# The difference between this and the other max, this computes across all rhos, employment and wage

dfj_top10 <- dfj %>%
    select(contains("rho_")) %>%
    reduce(pmin) %>%
    mutate(dfj, max_rank_rhos = .)

dfj_top10 <- dfj_top10 %>% filter(max_rank_rhos <= 10) %>%
  select(id, age, educ, black, hisp, marr, re74, re78, contains("rho_")) %>%
  arrange(age, educ, black, hisp)

# Graphing Library
library(kableExtra)
# Load Data
dt <- mtcars[1:5, 1:6]
# Generate latex string variable
st_out_tex <- kable(dfj_top10, "latex")
print(st_out_tex)
# File out
# fileConn <- file("./../../_file/tex/tex_sample_a_tab.tex")
fileConn <- file("C:/users/fan/HgtOptiAlloDraft/_tab/lalonda_wage_employ_top10.tex")
writeLines(st_out_tex, fileConn)
close(fileConn)

# Display results here
dfj_top10 %>%
    kable() %>%
    kable_styling(bootstrap_options = c("striped", "hover", "responsive"))
```
