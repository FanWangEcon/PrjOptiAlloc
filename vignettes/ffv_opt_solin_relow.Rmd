---
title: LINEAR--Optimal Linear Allocation based On Relative Allocation to Lowest
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{LINEAR--Optimal Linear Allocation based On Relative Allocation to Lowest}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
urlcolor: blue
---

Back to **[Fan](https://fanwangecon.github.io/)**'s Optimal Allocation Homepage **[Table of Content](https://fanwangecon.github.io/PrjOptiAlloc/)**

# Objective

Solves the linear optimal allocation problem. Each individual receives input $N_i$, and we are interested in individual expected outcomes $H_i$. Production functions or reduced causal form relationships are linear with individual specific slopes and intercepts. Solve for different planners.

# Load Packages and Data

## Set Up

```{r GlobalOptions, echo = T, results = 'hide', message=F, warning=F}
rm(list = ls(all.names = TRUE))
options(knitr.duplicate.label = 'allow')
```
```{r loadlib, echo = T, results = 'hide', message=F, warning=F}
#setwd('C:/Users/fan/PrjOptiAlloc')
library(dplyr)
library(tidyr)
library(stringr)
library(broom)
library(ggplot2)
library(REconTools)

library(PrjOptiAlloc)

library(knitr)
library(kableExtra)
```

## Get Data

Load data that is generated by regression [ffy_opt_dtgch_cbem4](https://fanwangecon.github.io/PrjOptiAlloc/reference/ffy_opt_dtgch_cbem4.html) ([vignette](https://fanwangecon.github.io/PrjOptiAlloc/articles/ffv_opt_dtgch_cbem4.html)).


```{r Load Data}
# Load Library
ls_opti_alpha_A <- ffy_opt_dtgch_cbem4()
df_raw <- ls_opti_alpha_A$df_raw
df_hw_cebu_m24 <- df_raw
df_esti <- ls_opti_alpha_A$df_esti

# Review dataframes
# raw file
head(df_raw, 10)
head(df_esti, 10)
ar_prot_data = df_hw_cebu_m24$prot
fl_N_agg = sum(ar_prot_data)

# Attach
attach(df_raw)
```

# Solve

I would like to be able to directly call the dataset generated here in various functions. Save the datafile we just created in the project folder.

## Prep Inputs

```{r}
df <- df_esti
svr_A_i <- 'A_lin'
svr_alpha_i <- 'alpha_lin'
svr_beta_i <- 'beta'
fl_N_agg <- fl_N_agg
fl_rho <- -10
```

## Relative Allocations

### Rank

```{r}
# a. select only relevant data
df_opti <- df %>% rename(A = !!sym(svr_A_i), alpha = !!sym(svr_alpha_i), beta = !!sym(svr_beta_i))

# b. Generate V4, Rank Index Value, rho specific
# df_opti <- df_opti %>% mutate(!!paste0('rv_', it_rho_ctr) := A/((alpha*beta))^(1/(1-fl_rho)))
df_opti <- df_opti %>% mutate(rank_val = A/((alpha*beta))^(1/(1-fl_rho)))

# c. Generate Rank Index
df_opti <- df_opti %>% arrange(rank_val) %>% mutate(rank_idx = row_number())

# d. Populate lowest index alpha, beta, and A to all rows
df_opti <- df_opti %>% mutate(lowest_rank_A = A[rank_idx==1]) %>%
              mutate(lowest_rank_alpha = alpha[rank_idx==1]) %>%
              mutate(lowest_rank_beta = beta[rank_idx==1])
# Print
head(df_opti, 10)
summary(df_opti)
summary(df_opti %>% select(lowest_rank_A, lowest_rank_alpha, lowest_rank_beta))
```

### Relative Slopes, Intercepts

```{r}
# e. relative slope and relative intercept with respect to lowest index
df_opti <- df_opti %>%
              mutate(rela_slope_to_lowest =
                        (((lowest_rank_alpha*lowest_rank_beta)/(alpha*beta))^(1/(fl_rho-1))*(lowest_rank_alpha/alpha))
                    ) %>%
              mutate(rela_intercept_to_lowest =
                        ((((lowest_rank_alpha*lowest_rank_beta)/(alpha*beta))^(1/(fl_rho-1))*(lowest_rank_A/alpha)) - (A/alpha))
                    )
# Print
summary(df_opti %>% select(rela_slope_to_lowest, rela_intercept_to_lowest))
```

## Spline and Inversion

### Summing up for Splines

```{r}
# f. cumulative sums
df_opti <- df_opti %>%
              mutate(rela_slope_to_lowest_cumsum =
                        cumsum(rela_slope_to_lowest)
                    ) %>%
              mutate(rela_intercept_to_lowest_cumsum =
                        cumsum(rela_intercept_to_lowest)
                    )
# Print
summary(df_opti %>% select(rela_slope_to_lowest_cumsum, rela_intercept_to_lowest_cumsum))
```

### Inverting Splines (Cumulative)

```{r}
# g. inverting cumulative slopes and intercepts
df_opti <- df_opti %>%
              mutate(rela_slope_to_lowest_cumsum_invert =
                        (1/rela_slope_to_lowest_cumsum)
                    ) %>%
              mutate(rela_intercept_to_lowest_cumsum_invert =
                        ((-1)*(rela_intercept_to_lowest_cumsum)/(rela_slope_to_lowest_cumsum))
                    )
# Print
summary(df_opti %>% select(rela_slope_to_lowest_cumsum_invert, rela_intercept_to_lowest_cumsum_invert))
```

### X intercepts as Spline Knots and inverted Spline Knots

```{r}

# h. Relative x-intercept points
df_opti <- df_opti %>%
              mutate(rela_x_intercept =
                        (-1)*(rela_intercept_to_lowest/rela_slope_to_lowest)
                    )

# i. Inverted relative x-intercepts
df_opti <- df_opti %>%
              mutate(opti_lowest_spline_knots =
                        (rela_intercept_to_lowest_cumsum + rela_slope_to_lowest_cumsum*rela_x_intercept)
                    )
# Print
summary(df_opti %>% select(rela_x_intercept, opti_lowest_spline_knots))
```

## Optimal Allocations
### Compute Optimal Allocation for the Lowest

```{r}

# j. Sort by order of receiving transfers/subsidies
df_opti <- df_opti %>% arrange(rela_x_intercept)

# k. Find position of subsidy
df_opti <- df_opti %>% arrange(opti_lowest_spline_knots) %>%
              mutate(tot_devi = opti_lowest_spline_knots - fl_N_agg) %>%
              arrange((-1)*case_when(tot_devi < 0 ~ tot_devi)) %>%
              mutate(allocate_lowest =
                        case_when(row_number() == 1 ~
                                    rela_intercept_to_lowest_cumsum_invert +
                                    rela_slope_to_lowest_cumsum_invert*fl_N_agg)) %>%
              mutate(allocate_lowest = allocate_lowest[row_number() == 1])
# Print
summary(df_opti %>% select(tot_devi, allocate_lowest))
```

### Compute Optimal Allocation for All Others given Lowest

```{r}
# l. Find position of subsidy
df_opti <- df_opti %>%
              mutate(opti_allocate =
                        rela_intercept_to_lowest +
                        rela_slope_to_lowest*allocate_lowest) %>%
              mutate(opti_allocate =
                        case_when(opti_allocate >= 0 ~ opti_allocate, TRUE ~ 0)) %>%
              mutate(allocate_total = sum(opti_allocate, na.rm=TRUE))

# if want 0 to be 0
# case_when(opti_allocate >= 0 ~ opti_allocate, TRUE ~ 0)) %>%
# if want 0 to be NA, makes it easier to see average change for non zeros
# case_when(opti_allocate >= 0 ~ opti_allocate)) %>%

# Print
summary(df_opti %>% select(opti_allocate, allocate_total))
```

## Expected Outcomes Given Optimal Allocations

```{r}

# l. Predictes Expected choice: A + alpha*opti_allocate
df_opti <- df_opti %>% mutate(opti_exp_outcome = A + alpha*opti_allocate)

# m. Drop some variables that I do not want to keep even in full df to export
# inpalc = input allocation optimal
# expout = expected outcome given input allocation
df_opti <- df_opti %>% select(-one_of(c('lowest_rank_alpha', 'lowest_rank_beta')))
ar_opti_inpalc <- df_opti %>% pull(opti_allocate)
ar_opti_expout <- df_opti %>% pull(opti_exp_outcome)

# Print
head(df_opti, 10)
summary(df_opti)
print(cbind(ar_opti_expout,ar_opti_inpalc))
```

# Save Outputs

```{r}
# df_opt_dtgch_ropti: dataframe, opt project, data guat cebu height, cebu edu mother, results relative linear optimal
df_opt_dtgch_cbem4_rrlop <- df_opti
usethis::use_data(df_opt_dtgch_cbem4_rrlop, df_opt_dtgch_cbem4_rrlop, overwrite = TRUE)
```

