---
title: Function Test Binary Allocation with Linear Regression
description: |
  Test binary optimal allocation solution function from package. 
  Use the the birthwt testing dataset. Regression birth weight on smoking status.
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Function Test Binary Allocation with Linear Regression}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
urlcolor: blue
---

The effects of mother's smoking status on birth weight. If we aim to improve health outcomes, what is the priority sequence of mothers whom we would want to discourage from smoking.

## Load Packages and Data

### Load Dependencies

```{r GlobalOptions, echo = T, results = 'hide', message=F, warning=F}
rm(list = ls(all.names = TRUE))
options(knitr.duplicate.label = 'allow')
```
```{r loadlib, echo = T, results = 'hide', message=F, warning=F}
library(dplyr)
library(tidyr)
library(tibble)
library(stringr)
library(broom)
library(ggplot2)
library(REconTools)

library(PrjOptiAlloc)

library(knitr)
library(kableExtra)
```

### Load Data

Generate four categories by initial height and mother's education levels combinations.

```{r Load Packages and Process Data}
# Load Data
data(df_opt_birthwt)

# Summarize
str(df_opt_birthwt)
summary(df_opt_birthwt)

# Generate Discrete Version of continuous variables
df_opt_birthwt <- df_opt_birthwt %>%
    mutate(momwgtLowHigh = cut(lwt,
                               breaks=c(-Inf, 129, Inf),
                               labels=c("LW","HW"))) %>%
    mutate(mombirthage = cut(age,
                               breaks=c(-Inf, 24, Inf),
                               labels=c("young","older"))) %>%
    mutate(ftvm3 = cut(ftv,
                               breaks=c(-Inf, 1, 2, Inf),
                               labels=c("novisit","1visit","morevisit")))

attach(df_opt_birthwt)
summary(df_opt_birthwt)

# tabulate
df_opt_birthwt %>%
  group_by(race, smoke, ftv) %>%
  summarize(freq = n()) %>%
  pivot_wider(names_from = race, values_from = freq)

summary(lm(bwt ~ lwt + factor(mombirthage) + factor(race) + factor(ht) + factor(ui)))
summary(lm(bwt ~ lwt + age + factor(race) + factor(race):factor(smoke) - 1))
summary(lm(bwt ~ lwt + age + factor(race) + factor(race):factor(smoke) - 1))

summary(lm(bwt ~ factor(ftv) - 1))
summary(lm(bwt ~ factor(ftv) + factor(ht) + factor(ui) + factor(ptl) - 1))

summary(lm(bwt ~ lwt + factor(race) + (ftv) - 1))
```

## Regression with Data and Construct Input Arrays

### Binary Problem Regress Birth Weight on Mother's Smoking Status

```{r Linear Regression Testing}
# A. Regress child birth weight on mother's age, race and mother's weight
print(summary(lm(bwt ~ lwt + factor(mombirthage) + factor(race))))
print(summary(lm(bwt ~ lwt + factor(mombirthage) + factor(race) + factor(ht) + factor(ui))))
print(summary(lm(bwt ~ lwt + age + factor(race) + factor(ht) + factor(ui) + factor(ptl))))

print(summary(lm(bwt ~ lwt + age + factor(race) + factor(smoke))))
print(summary(lm(bwt ~ lwt + age + factor(race) + factor(ht) + factor(ui) +  factor(smoke))))

print(summary(lm(bwt ~ lwt + age + factor(momwgtLowHigh):factor(smoke) - 1)))
print(summary(lm(bwt ~ lwt + age + factor(ht) + factor(ui) + factor(race) + factor(race):factor(smoke))))
print(summary(lm(bwt ~ lwt + age + factor(race) + factor(race):factor(smoke) - 1)))

# Preferred way of appearing, in the following regression we can se:
# 1. more more power less MPG, Straight engine slightly higher MPG
# 2. V-shape engine car, going from auto to manual trans gain 4.1 MPG
# 2. straight shape engine, going from auto to manual trans gain 6.67 MPG

# Store Regression Results
mt_model <- model.matrix(~ lwt + age + factor(ht) + factor(ui) + factor(ptl) + factor(race) + factor(smoke):factor(race))
rs_wgt_on_smke = lm(bwt ~ mt_model - 1)
print(summary(rs_wgt_on_smke))
rs_wgt_on_smke_tidy = tidy(rs_wgt_on_smke)
rs_wgt_on_smke_tidy
```

### Construct Input Arrays $A_i$ and $\alpha_i$

Multiply coefficient vector by covariate matrix to generate *A* vector that is child/individual specific.

```{r Post Regression Input Processing}
# Estimates Table
head(rs_wgt_on_smke_tidy, 6)
# Covariates
head(mt_model, 5)

# Covariates coefficients from regression (including constant)
ar_fl_cova_esti <- as.matrix(rs_wgt_on_smke_tidy %>% filter(!str_detect(term, 'smoke')) %>% select(estimate))
ar_fl_main_esti <- as.matrix(rs_wgt_on_smke_tidy %>% filter(str_detect(term, 'smoke')) %>% select(estimate))
head(ar_fl_cova_esti, 5)
head(ar_fl_main_esti, 5)

# Select Matrix subcomponents
mt_cova <- as.matrix(as_tibble(mt_model) %>% select(-contains("smoke")))
mt_intr <- model.matrix(~ factor(race) - 1)

# Generate A_i, use mt_cova_wth_const
ar_A_m <- mt_cova %*% ar_fl_cova_esti
head(ar_A_m, 5)

# Generate alpha_i
ar_alpha_m <- mt_intr %*% ar_fl_main_esti
head(ar_alpha_m, 5)
```

### Individual Weight

```{r}
# Child Weight
ar_beta_m <- rep(1/length(ar_A_m), times=length(ar_A_m))
```

### Matrix with Required Inputs for Allocation

```{r}
# Initate Dataframe that will store all estimates and optimal allocation relevant information
# combine identifying key information along with estimation A, alpha results
# note that we only need indi.id as key
mt_opti <- cbind(ar_alpha_m, ar_A_m, ar_beta_m)
ar_st_varnames <- c('alpha', 'A', 'beta')
df_esti_alpha_A_beta <- as_tibble(mt_opti) %>% rename_all(~c(ar_st_varnames))
tb_key_alpha_A_beta <- bind_cols(df_opt_birthwt, df_esti_alpha_A_beta) %>%
              select(one_of(c('Index', 'age', 'lwt', 'race', 'smoke', 'ptl', 'ht', 'ui', ar_st_varnames)))

# Need to only include the smokers here
# tb_key_alpha_A_beta <- tb_key_alpha_A_beta %>% filter(smoke == 1)
# Randomly select 30 people
set.seed(123)
it_include <- 30
tb_key_alpha_A_beta <- tb_key_alpha_A_beta[sample(dim(tb_key_alpha_A_beta)[1], it_include, replace=FALSE),]

# Unique beta, A, and alpha check
tb_opti_unique <- tb_key_alpha_A_beta %>% group_by(!!!syms(ar_st_varnames)) %>%
                    arrange(!!!syms(ar_st_varnames)) %>%
                    summarise(n_obs_group=n())

# Show cars
head(tb_key_alpha_A_beta, 32)
```

## Optimal Linear Allocations

### Parameters for Optimal Allocation

```{r Set Allocation Parameters}
# Child Count
it_obs = dim(tb_opti_unique)[1]

# Vector of Planner Preference
ar_rho <- c(-100, 0.8)
ar_rho <- c(-50, -25, -10)
ar_rho <- c(-100, -5, -1, 0.1, 0.6, 0.8)
ar_rho <- c(seq(-200, -100, length.out=5), seq(-100, -25, length.out=5), seq(-25, -5, length.out=5), seq(-5, -1, length.out=5), seq(-1, -0.01, length.out=5), seq(0.01, 0.25, length.out=5), seq(0.25, 0.90, length.out=5))
ar_rho <- c(-100, -5, -1, 0.1, 0.6, 0.99)
ar_rho <- c(-100, -10, -1, 0.05, 0.9)
ar_rho <- 1 - (10^(c(seq(-2,2, length.out=10))))
ar_rho <- c(-100, -10, -1, -0.5, -0.1, 0.01, 0.05, 0.10, 0.20,  0.9)
ar_rho <- c(seq(-110, -90, length.out=10), -50, 10, -1, -0.5, -0.1, 0.01, 0.05, 0.10, 0.20,  0.9)
ar_rho <- unique(ar_rho)
```

### Optimal binary Allocation

This also works with any CRS CES.

```{r Optimal Linear Allocation Hard Code All Rho}
# Optimal Linear Equation
svr_inpalc <- 'rank'

# Solve with Function
ls_bin_solu_all_rhos <-
  ffp_opt_anlyz_rhgin_bin(tb_key_alpha_A_beta, svr_id_i = 'Index',
                          svr_A_i = 'A', svr_alpha_i = 'alpha', svr_beta_i = 'beta',
                          ar_rho = ar_rho,
                          svr_inpalc = svr_inpalc,
                          svr_expout = 'opti_exp_outcome')

tb_opti_alloc_all_rho <- ls_bin_solu_all_rhos$df_all_rho
tb_opti_alloc_all_rho_long <- ls_bin_solu_all_rhos$df_all_rho_long

# Converge rho to numeric so the graph below sorts along x-axis properly 
tb_opti_alloc_all_rho_long <- tb_opti_alloc_all_rho_long %>% mutate(rho_num = as.numeric(rho))

# Merge to get Race Data
tb_opti_alloc_all_rho_long <- tb_opti_alloc_all_rho_long %>% 
  left_join(tb_key_alpha_A_beta %>% select(Index, race), by='Index')
```

### Bump Plot for Optimal Binary Allocations

```{r binary allocation bump plot, fig.height = 10, fig.width = 10, fig.align = "center"}

tb_opti_alloc_all_rho_long %>%
  ggplot(aes(x = rho_num, y = !!sym(svr_inpalc), group = Index)) +
    geom_line(aes(color = race, alpha = 1), size = 2) +
    geom_point(aes(color = race, alpha = 1), size = 4) +
    scale_x_discrete(expand = c(0.85,0))+
    scale_y_reverse(breaks = 1:nrow(tb_opti_alloc_all_rho_long))+
    theme(legend.position = "none") +
    labs(x = "Equality vs Efficiency",
         y = "Rank",
         title = "Binary Deallocation Rank, Weight and Smokng") +
    ffy_opt_ghthm_dk() +
    geom_text(data =tb_opti_alloc_all_rho,aes(y=rho_c1_rk,x=0.6,label=Index),hjust="right")

```
