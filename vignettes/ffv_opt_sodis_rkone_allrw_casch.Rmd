---
title: DISCRETE--Discrete Provision Optimal Allocation Solution (Line by Line)
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{DISCRETE--Discrete Provision Optimal Allocation Solution (Line by Line)}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
urlcolor: blue
---

Back to **[Fan](https://fanwangecon.github.io/)**'s Optimal Allocation Homepage **[Table of Content](https://fanwangecon.github.io/PrjOptiAllo==c/)**

# Objective

The california school dataset, the effect of teacher ratio on student scores.

# Load Packages and Data

## Load Dependencies

```{r GlobalOptions, echo = T, results = 'hide', message=F, warning=F}
rm(list = ls(all.names = TRUE))
options(knitr.duplicate.label = 'allow')
```
```{r loadlib, echo = T, results = 'hide', message=F, warning=F}
library(dplyr)
library(tidyr)
library(tibble)
library(stringr)
library(broom)
library(ggplot2)
library(REconTools)

library(PrjOptiAlloc)

library(knitr)
library(kableExtra)
```

## Policy Parameters


```{r control policy}
# 100 percent teacher at most per school, discretize floor as needed
fl_max_add_teacher_percent = 1.00
# 20 percent total additional of all teachers
fl_teacher_increase_percent = 0.20
# Rho values to consider
ar_rho <- 1 - (10^(c(seq(-2,2, length.out=4))))
```

## Load Data

Generate four categories by initial height and mother's education levels combinations. Note the dataset does not provide all the details we want, so we will make some assumptions. Importantly, we only have averages within district. 

1. *teachers*: is full-time-equivalent average number of teacher per district. 
2. *enrl_tot*: is the enrollment average per district


```{r Load Packages and Process Data}
# Load Data
data(df_opt_caschool)
dfca <- df_opt_caschool

# Summarize
str(dfca)
summary(dfca)
dfca %>% group_by(county) %>%
  summarise_if(is.numeric, funs(mean = mean), na.rm = TRUE)

# Modifying and labeling etc.
# School characteristics are averaged across the district, don't know school count per district, implicitly assume the number of schools per district is the same.
# Some districts have larger and others smaller sized schools, ignoring within district variations.
dfca <- dfca %>%
          mutate(id = X) %>% select(-X) %>%
          select(id, everything()) %>%
          mutate(teachers = round(teachers),
                 enrltot = round(enrltot))

# Student and Teacher Ratio, str and stravg are almost identical
# use stravg because need to use enrltot and teachers variables later
dfca <- dfca %>% mutate(stravg = enrltot/teachers)
# view(dfca %>% select(stravg, str))

# Generate Discrete Version of continuous variables
# df_opt_birthwt <- df_opt_birthwt %>%
#     mutate(momwgtLowHigh = cut(lwt,
#                                breaks=c(-Inf, 129, Inf),
#                                labels=c("LW","HW"))) %>%
#     mutate(mombirthage = cut(age,
#                                breaks=c(-Inf, 24, Inf),
#                                labels=c("young","older"))) %>%
#     mutate(ftvm3 = cut(ftv,
#                                breaks=c(-Inf, 1, 2, Inf),
#                                labels=c("novisit","1visit","morevisit")))
```

# Regression with Data

## Tabulate

```{r tabulate groups}
# Tabulate groups, how many in each group, enough for group heterogeneity in effects?
dfca %>%
  group_by(county, grspan) %>%
  summarize(freq = n()) %>%
  pivot_wider(names_from = grspan, values_from = freq)
```

## Regression Testing

The allocation policy is in terms of teachers. How many teachers to add. Given the current number of teachers in the school, suppose there is some capacity limit at each school, so the number of additional teachers at each school can not exceed 35 percent of the teachers that are already there.

Our estimation is based on regressing thest score on the student teacher ratio, from which we obtain a single estimate $\alpha$.

$$
Y_i = A_i + \theta \cdot \frac{S_i}{T_i} + \epsilon
$$

What is the marginal effect of adding one more unit?

What is the effect of adding an additional teacher?

We need to translate the estimate $\theta$ here into our equation's allocation scale

$$
Y_i \left(T_i\right) = A_i + \theta \cdot \frac{S_i}{T_i} + \epsilon\\
Y_i \left(T_i + 1\right) = A_i + \theta \cdot \frac{S_i}{T_i + 1} + \epsilon\\
EY_i \left(T_i + 1\right) - EY_i \left(T_i\right) = \theta \cdot S_i \cdot \left( \frac{1}{T_i + 1} - \frac{1}{T_i} \right)
$$

```{r Regression Testing}
attach(dfca)

# Math, English, and Overall and str = student teacher ratio
summary(lm(mathscr ~ str))
summary(lm(readscr ~ str))
summary(lm(testscr ~ str))
summary(lm(testscr ~ stravg))

# Regress test score on str with student and teacher counts
summary(lm(testscr ~ enrltot + teachers + str))
summary(lm(testscr ~ enrltot + teachers + stravg))

# Regress test score on str with covariates and county fe
summary(lm(testscr ~ factor(county) + calwpct + mealpct + computer + str - 1))
summary(lm(testscr ~ factor(county) + calwpct + mealpct + computer + stravg - 1))
```

## Discrete Regression

Need to convert regression results to increment effect.

```{r}
# Store Regression Results
mt_model <- model.matrix( ~ factor(county) + calwpct + mealpct + computer + stravg)
rs_scr_on_str = lm(testscr ~ mt_model - 1)
print(summary(rs_scr_on_str))
rs_scr_on_str_tidy = tidy(rs_scr_on_str)
rs_scr_on_str_tidy
```

## Construct Input Arrays $A_i$

Multiply coefficient vector by covariate matrix to generate *A* vector that is child/individual specific.

```{r Post Regression Input Processing}
# Estimates Table
head(rs_scr_on_str_tidy, 6)
# Covariates
head(mt_model, 5)

# Covariates coefficients from regression (including constant)
ar_fl_cova_esti <- as.matrix(rs_scr_on_str_tidy %>% filter(!str_detect(term, 'stravg')) %>% select(estimate))
ar_fl_main_esti <- as.matrix(rs_scr_on_str_tidy %>% filter(str_detect(term, 'stravg')) %>% select(estimate))
head(ar_fl_cova_esti, 5)
head(ar_fl_main_esti, 5)

# Select Matrix subcomponents
mt_cova <- as.matrix(as_tibble(mt_model) %>% select(-contains("stravg")))
# mt_intr <- model.matrix(~ factor(race) - 1)
mt_intr <- t(t(rep(1, dim(mt_model)[1])))

# Generate A_i, use mt_cova_wth_const
ar_A_m <- mt_cova %*% ar_fl_cova_esti
head(ar_A_m, 5)

# Generate temporary theta_i (alpha elswhere, but theta here, because how student count will enter
ar_theta_m <- mt_intr %*% ar_fl_main_esti
head(ar_theta_m, 5)

# Beta
ar_beta_m <- rep(1/length(ar_A_m), times=length(ar_A_m))

# Dataframe of A and temporary theta
mt_A_theta_beta <- cbind(ar_A_m, ar_theta_m, ar_beta_m)

colnames(mt_A_theta_beta) <- c('A_i', 'theta_i', 'beta_i')
```

# Effect of an Additional Teacher and Target Queue 

## Step zero, one and two

**Step 0**

*mt_ori*: this is the original dataframe with all variables, each row is a different observation

**Step 1**

*mt_a*: Six column matrix: col 1, district index, col 2, max number of additional teachers each district could acquire (which is determined by the number of existing teachers). There could be a maximum and minimum overall, 0 and say 100 additional teacers per district at most regardless. And each district gets up to potentially 25 percent or 30 percent additional teachers. Col 3, the number of current level of teachers in the district. Col 4, the number of current number of students. Col 5, the A_i without the addition of teacher student ratio. Col 6, not alpha_i, but just the coefficient theta that might be already individual specific due to earlier regression allowing for interaction, the alpha_i which is the $\theta_i$ possibly heterogeneous effects of str on outcomes of interest.

**Step 2**

*mt_b*: expand *mt_a*. Each row is a feasible additional teacher for a district, each there are now five variables, ID, previous level of teachers, and new level of teachers, and the existing level of students, and original A_i.

```{r generate longer dataframe}
# dfca_exmain: dfca expand main frame, five variables
# Dunif_i: uniform allocation results, note ROUND
dfca <- dfca %>% mutate(Dmax_i = floor(fl_max_add_teacher_percent*teachers)) %>% 
  mutate(Dunif_i = round(fl_teacher_increase_percent*teachers))

dfca_exmain_i <- dfca %>% select(id, Dmax_i, Dunif_i, teachers, enrltot)
dfca_exmain_i <- cbind(dfca, mt_A_theta_beta)

# following: https://fanwangecon.github.io/R4Econ/summarize/count/fs_count_basics.html
# teachers is a count coloumn to expand by 
# i_d_l is each incremental teacher
# teachers_addl is existing teacher level added up to current l
dfca_exmain <- dfca_exmain_i %>% uncount(Dmax_i) %>% 
                  group_by(id) %>% 
                  mutate(i_d_l = row_number()) %>% 
                  mutate(teachers_addl = teachers + i_d_l - 1)

# Generate Dmax_i again, which disapeared due to uncount
dfca_exmain <- dfca_exmain %>% mutate(Dmax_i = floor(fl_max_add_teacher_percent*teachers))

# display
kable(dfca_exmain[0:25,]) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))
```

## Step Three and Four

**Step 3**

*mt_b*: add a alpha_i column, generate the marginal productivity value, and also generate actual updated A_i. Apply the formula stated earlier. 

**Step 4**

*mt_c*: merge together the matrix now has alpha_i with also the already existing A_i.

```{r marginal effect of an additional teacher here, fig.height = 4, fig.width = 6, fig.align = "center"}
# Generate alpha_i for each additional teacher
dfca_exmain <- dfca_exmain %>% mutate(alpha_il = theta_i*enrltot*((1/teachers_addl) - (1/(teachers_addl-1)))) %>%
                                   mutate(A_il = A_i + theta_i*(enrltot/(teachers_addl-1))) %>%
                                   rowid_to_column(var = "IDil")

# Graph of the Distribution of Alpha_i and A_i
scatter <- dfca_exmain %>% ggplot(aes(x=A_il)) +
      geom_point(aes(y=log(alpha_il)), size=4, shape=4, color="red") +
      geom_abline(intercept = 0, slope = 1) + # 45 degree line
      labs(title = paste0('Discrete Allocation\nCalifornia Test Score and Student Teacher Ratio\nThe Relationship between A_il and alpha_il'),
           x = 'A_il = EXAM(teacher current + n)',
           y = 'log(alpha_il = E(teacher + n + 1) - E(teacher + n))',
           caption = paste0('Stock and Watson California Test and STR')) +
      theme_bw()
      
print(scatter)


# display
kable(dfca_exmain[0:75,]) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))
```

## Step Five

**Step 5**

Sort, and select top given total resource avaiable, The count the total allocation for each. This means to invoke the binary allocation function. 

```{r invoke the optimal targeting function}
# Optimal Targeting
dfca_exmain_target <- dfca_exmain %>% ungroup(id) %>% select(IDil, Dmax_i, A_il, alpha_il, beta_i)
# ar_rho = c(-100, -0.001,  0.95)
ar_rho <- unique(ar_rho)
ls_bin_solu_all_rhos <-
  ffp_opt_anlyz_rhgin_bin(dfca_exmain_target, svr_id_i = 'IDil',
                          svr_A_i = 'A_il', svr_alpha_i = 'alpha_il', svr_beta_i = 'beta_i',
                          ar_rho = ar_rho,
                          svr_inpalc = 'opti_alloc_queue',
                          svr_expout = 'opti_exp_outcome')
  
# Results from optimal targeting
df_all_rho <- ls_bin_solu_all_rhos$df_all_rho
df_all_rho <- df_all_rho %>% left_join(dfca_exmain %>% select(IDil, id, teachers,enrltot, theta_i, i_d_l, teachers_addl), by='IDil')
df_all_rho_long <- ls_bin_solu_all_rhos$df_all_rho_long

# display
kable(df_all_rho[0:100,]) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))
```

# Optimally Allocate

In the problem here, I am expanding total teaching research by 10 percent, so what is the total number of teachers that are in all schools currently, 

```{r allocate given resource}
# What is the number of teachers we can increase by
fl_teacher_increase_number <- sum(dfca$teachers)*fl_teacher_increase_percent
fl_teacher_increase_number <- floor(fl_teacher_increase_number)

# We can increase teacher count
cat('this is W = fl_teacher_increase_number:', fl_teacher_increase_number, '\n')

# What is the number of candidate recipient now in il unit 
cat('fl_max_add_teacher_percent:', fl_max_add_teacher_percent, '\n')
cat('this is N = total candidate slots = dim(df_all_rho)[1]:', dim(df_all_rho)[1], '\n')
```

## Determine Allocation Count Cutoffs

Already have almost fully solved the problem. Need to do one extra thing here. 

Given the $Q_{il}$ ranking, do the following, for each $\lambda$:

1. Select only relevant columns for current calulcation:
    - $i$ indicator variable
    - $l$ within i counter for additional increments
    - $Q_{il}$ targeting queue ranking
2. If $Q_{il}\left(\lambda\right) \le \widehat{W}$, set $A_{il}\left(\lambda\right) = 1$, otherwise $0$
3. Group by and Sum for each $i$ over $l$, total will be between $0$ and $\bar{D}$, mutate new $D_{i} = \sum_l 1\left\{ Q_{il} < \widehat{W} \right\}$
4. Loop over $\lambda$ and finish


The implementation below is actually different, uses the *rho_long* file

1. Generate $A_{il}$ from from long file with all $\lambda$
2. Join long file with wide file key variables, includes $D_i$, individual max count as well as id. 
3. Also generate $F_i = \frac{D_i}{Dmax_i}$

```{r, aggregateing allocation for individual across units}
# Generate A_il
df_all_rho_long_Ail <- df_all_rho_long %>%
  select(IDil, rho, rank) %>%
  mutate(A_il = case_when(rank <= fl_teacher_increase_number ~ 1, TRUE ~ 0)) %>%
  select(IDil, rho, A_il) %>%
  left_join(df_all_rho %>% select(IDil, id, Dmax_i), by='IDil') %>%
  select(id, rho, Dmax_i, A_il) 

# Generate D_i and F_i long
df_all_rho_long_D_i <- df_all_rho_long_Ail %>%
  group_by(id, rho) %>%
  summarize(D_i = sum(A_il), Dmax_i = mean(Dmax_i),
            F_i = D_i/Dmax_i) %>%
  mutate(rho = as.numeric(rho)) %>%
  arrange(id, rho)

# Generate D_i Wide
df_all_rho_D_i <- df_all_rho_long_D_i %>%
  select(id, rho, F_i, Dmax_i) %>%
  mutate(rho = as.numeric(rho)) %>%
  pivot_wider(
    names_from = 'rho',
    values_from = 'F_i'
  )
  
# Rename rho columns and merge with key district attributes
st_last_rho <- paste0('rho', length(ar_rho))
df_all_rho_D_i <- df_all_rho_D_i %>%
  rename_at(vars(num_range('', paste0(seq(1, length(ar_rho))))), 
            funs(paste0("rho",.))) %>%
  left_join(dfca %>% 
              select(id, distcod, county, district, grspan,
                     enrltot, teachers, avginc, testscr, stravg), 
            by='id') %>%
  select(id, distcod, county, district, grspan, avginc, testscr, enrltot, teachers, stravg, everything()) %>%
  mutate(rho_diff = (!!sym(st_last_rho) - rho1))

  # mutate(rho_diff = 
  #          case_when(
  #            (abs(!!sym(st_last_rho) - rho1) == 0) & (rho1 == 0) ~ -2,
  #            (abs(!!sym(st_last_rho) - rho1) == 0) & (rho1 == 1) ~ 2,
  #            TRUE ~ !!sym(st_last_rho) - rho1))
  
# Display Results
kable(df_all_rho_D_i[1:420,] %>% mutate_if(is.numeric, round, 2)) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))
```

## Allocation Distribution Analysis

Given the allocations we have, not

```{r summarize by lambda}

df <- df_all_rho_long_D_i
vars.group <- c('rho')
var.numeric <- 'F_i'
str.stats.group <- 'allperc'
ar.perc <- c(0.01, seq(0.05,0.95,by=0.05), 0.99)
ls_summ_by_group <- ff_summ_bygroup(df, vars.group, var.numeric, str.stats.group, ar.perc)
df_table_grp_stats <- ls_summ_by_group$df_table_grp_stats
df_row_grp_stats <- ls_summ_by_group$df_row_grp_stats
df_overall_stats <- ls_summ_by_group$df_overall_stats
df_row_stats_all <- ls_summ_by_group$df_row_stats_all

# Display Results
kable(df_table_grp_stats) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))
```

# Resource Equivalent Variations

Resource Equivalent Variation, compare against evenly increasing allocation by the same percentage across all schools. 

## Compare Total Resource Usages

Check the following:

1. Total optimal allocation each rho, is resource constraint satisfied
2. What would it mean to uniformly allocate across all individuals, total sum from uniform allocation
    + uniform addition for each school was already calculated

```{r}
# Total optimal allocation each row, should equal to fl_teacher_increase_number
df_all_rho_long_D_i %>%
  group_by(rho) %>%
  summarize(sum_D_i = sum(D_i)) %>%
  mutate(summ_D_i_correct = case_when(fl_teacher_increase_number == sum_D_i ~ 1,
                                      TRUE ~ 0 ))

# What is the uniform allocation total
dfca %>% summarize(sum_Dunif_i = sum(Dunif_i))
```

## Within School Cumulative Sum

To build up overall value, calculate the utility contribution of school to overall functional form, at each increment of teacher.
 
Generate the $il$ aggregated at $i$ level utility component dataframe:

1. by each school 
2. within each school, value of each additional teacher
3. within each school, row by row, cumulative sum of value of additional techer
4. within each school, row by row, common individual school functional form

## Utility for Any Observed Allocation 

Merge the data utility component dataframe with the random/uniform allocation frame. And simple sum for total utility. 

1. Select from main file id column and observed/unif/random allocation colummn
2. Merge main left_join with utility component dataframe, only keep on row
3. Simple Sum and Outter power form to generate overall utility from observed allocations

## Utility from Optimal Allocations

The goal is to generate a different optimal allocation level for each $\widehat{W}$ level of aggregate resources, should be increasing with $\widehat{W}$.

This is trickier than for binary allocation, because here there is the problem of double counting if I simply cumulatively sum up the utility component dataframe. 

So the process will be to first do simple cumulative sum, and then generate $\widehat{W}$ increment by increment double counted values, and then substract their values from the cumulative sum. This is the slightly challenging part. How to figure out at each $\widehat{W}$, how many of the elements in the targeting queue below $Q_{il} \le \widehat{W}$ should be dropped?
















