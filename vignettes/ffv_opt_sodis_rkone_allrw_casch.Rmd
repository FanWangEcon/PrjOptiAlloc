---
title: DISCRETE--Discrete Provision Optimal Allocation Solution (Line by Line)
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{BINARY--Binary Provision Optimal Allocation Solution (Line by Line)}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
urlcolor: blue
---

Back to **[Fan](https://fanwangecon.github.io/)**'s Optimal Allocation Homepage **[Table of Content](https://fanwangecon.github.io/PrjOptiAllo==c/)**

# Objective

The california school dataset, the effect of teacher ratio on student scores.

# Load Packages and Data

## Load Dependencies

```{r GlobalOptions, echo = T, results = 'hide', message=F, warning=F}
rm(list = ls(all.names = TRUE))
options(knitr.duplicate.label = 'allow')
```
```{r loadlib, echo = T, results = 'hide', message=F, warning=F}
library(dplyr)
library(tidyr)
library(tibble)
library(stringr)
library(broom)
library(ggplot2)
library(REconTools)

library(PrjOptiAlloc)

library(knitr)
library(kableExtra)
```

## Load Data

Generate four categories by initial height and mother's education levels combinations.

```{r Load Packages and Process Data}
# Load Data
data(df_opt_caschool)

# Summarize
str(df_opt_caschool)
summary(df_opt_caschool)
df_opt_caschool %>% group_by(county) %>%
  summarise_if(is.numeric, funs(mean = mean), na.rm = TRUE)

# Modifying and labeling etc.
# School characteristics are averaged across the district, don't know school count per district, implicitly assume the number of schools per district is the same. 
# Some districts have larger and others smaller sized schools, ignoring within district variations. 
df_opt_caschool <- df_opt_caschool %>%
                      mutate(id = X) %>%
                      mutate(teachers = round(teachers), 
                             enrltot = round(enrltot))

# Generate Discrete Version of continuous variables
# df_opt_birthwt <- df_opt_birthwt %>%
#     mutate(momwgtLowHigh = cut(lwt,
#                                breaks=c(-Inf, 129, Inf),
#                                labels=c("LW","HW"))) %>%
#     mutate(mombirthage = cut(age,
#                                breaks=c(-Inf, 24, Inf),
#                                labels=c("young","older"))) %>%
#     mutate(ftvm3 = cut(ftv,
#                                breaks=c(-Inf, 1, 2, Inf),
#                                labels=c("novisit","1visit","morevisit")))
```

# Regression with Data and Construct Input Arrays

## Tabulate

```{r tabulate groups}
# Tabulate groups, how many in each group, enough for group heterogeneity in effects?
df_opt_caschool %>%
  group_by(county, grspan) %>%
  summarize(freq = n()) %>%
  pivot_wider(names_from = grspan, values_from = freq)
```

## Regression Testing

The allocation policy is in terms of teachers. How many teachers to add. Given the current number of teachers in the school, suppose there is some capacity limit at each school, so the number of additional teachers at each school can not exceed 35 percent of the teachers that are already there.

Our estimation is based on regressing thest score on the student teacher ratio, from which we obtain a single estimate $\alpha$.

$$
Y_i = A_i + \theta \cdot \frac{S_i}{T_i} + \epsilon
$$

What is the marginal effect of adding one more unit?

What is the effect of adding an additional teacher?

We need to translate the estimate $\theta$ here into our equation's allocation scale

$$
Y_i \left(T_i\right) = A_i + \theta \cdot \frac{S_i}{T_i} + \epsilon\\
Y_i \left(T_i + 1\right) = A_i + \theta \cdot \frac{S_i}{T_i + 1} + \epsilon\\
EY_i \left(T_i + 1\right) - EY_i \left(T_i\right) = \theta \cdot S_i \cdot \left( \frac{1}{T_i + 1} - \frac{1}{T_i} \right)
$$

```{r Regression Testing}
attach(df_opt_caschool)

# Math, English, and Overall and str = student teacher ratio
summary(lm(mathscr ~ str))
summary(lm(readscr ~ str))
summary(lm(testscr ~ str))

# Regress test score on str with student and teacher counts
summary(lm(testscr ~ enrltot + teachers + str))

# Regress test score on str with covariates and county fe
summary(lm(testscr ~ factor(county) + calwpct + mealpct + computer
                     + str - 1))
```

## Discrete Regression

Need to convert regression results to increment effect.

```{r}
# Store Regression Results
mt_model <- model.matrix( ~ factor(county) + calwpct + mealpct + computer + str)
rs_scr_on_str = lm(testscr ~ mt_model - 1)
print(summary(rs_scr_on_str))
rs_scr_on_str_tidy = tidy(rs_scr_on_str)
rs_scr_on_str_tidy
```

## Construct Input Arrays $A_i$ 

Multiply coefficient vector by covariate matrix to generate *A* vector that is child/individual specific.

```{r Post Regression Input Processing}
# Estimates Table
head(rs_scr_on_str_tidy, 6)
# Covariates
head(mt_model, 5)

# Covariates coefficients from regression (including constant)
ar_fl_cova_esti <- as.matrix(rs_scr_on_str_tidy %>% filter(!str_detect(term, 'str')) %>% select(estimate))
ar_fl_main_esti <- as.matrix(rs_scr_on_str_tidy %>% filter(str_detect(term, 'str')) %>% select(estimate))
head(ar_fl_cova_esti, 5)
head(ar_fl_main_esti, 5)

# Select Matrix subcomponents
mt_cova <- as.matrix(as_tibble(mt_model) %>% select(-contains("str")))

# Generate A_i, use mt_cova_wth_const
ar_A_m <- mt_cova %*% ar_fl_cova_esti
head(ar_A_m, 5)

# Generate alpha_i, in this problem, the alpha_i is generated differently. 
```

## Individual alpha_i

So this task is less trivial to do here. The procedure will be the following, 

**Step 0**

*mt_ori*: this is the original dataframe with all variables, each row is a different observation

**Step 1**

*mt_a*: Five column matrix: col 1, district index, col 2, max number of additional teachers each district could acquire (which is determined by the number of existing teachers). There could be a maximum and minimum overall, 0 and say 100 additional teacers per district at most regardless. And each district gets up to potentially 25 percent or 30 percent additional teachers. Col 3, the number of current level of teachers in the district. Col 4, the number of current number of students. Col 5, the A_i without the addition of teacher student ratio. 

**Step 2**

*mt_b*: expand *mt_a*. Each row is a feasible additional teacher for a district, each there are now five variables, ID, previous level of teachers, and new level of teachers, and the existing level of students, and original A_i. 

**Step 3**

*mt_b*: add a alpha_i column, generate the marginal productivity value, and also generate actual updated A_i.

**Step 4**

*mt_c*: merge together the matrix now has alpha_i with also the already existing A_i.

**Step 5**

Sort, and select top given total resource avaiable, The count the total allocation for each.

Back to dataframe mt_ori, incorporate into that, but do and shift for each rho. 

```{r}
# Child Weight
ar_beta_m <- rep(1/length(ar_A_m), times=length(ar_A_m))
```

## Matrix with Required Inputs for Allocation

```{r}
# Initate Dataframe that will store all estimates and optimal allocation relevant information
# combine identifying key information along with estimation A, alpha results
# note that we only need indi.id as key
mt_opti <- cbind(ar_alpha_m, ar_A_m, ar_beta_m)
ar_st_varnames <- c('alpha', 'A', 'beta')
df_esti_alpha_A_beta <- as_tibble(mt_opti) %>% rename_all(~c(ar_st_varnames))
tb_key_alpha_A_beta <- bind_cols(df_opt_birthwt, df_esti_alpha_A_beta) %>%
              select(one_of(c('Index', 'age', 'lwt', 'race', 'smoke', 'ptl', 'ht', 'ui', ar_st_varnames)))

# Need to only include the smokers here
tb_key_alpha_A_beta <- tb_key_alpha_A_beta %>% filter(smoke == 1)

# Unique beta, A, and alpha check
tb_opti_unique <- tb_key_alpha_A_beta %>% group_by(!!!syms(ar_st_varnames)) %>%
                    arrange(!!!syms(ar_st_varnames)) %>%
                    summarise(n_obs_group=n())

# Show cars
head(tb_key_alpha_A_beta, 32)
```

# Optimal Linear Allocations

## Parameters for Optimal Allocation

```{r Set Allocation Parameters}
# Child Count
it_obs = dim(tb_opti_unique)[1]

# Vector of Planner Preference
ar_rho <- c(-100, 0.8)
ar_rho <- c(-50, -25, -10)
ar_rho <- c(-100, -5, -1, 0.1, 0.6, 0.8)
ar_rho <- c(seq(-200, -100, length.out=5), seq(-100, -25, length.out=5), seq(-25, -5, length.out=5), seq(-5, -1, length.out=5), seq(-1, -0.01, length.out=5), seq(0.01, 0.25, length.out=5), seq(0.25, 0.90, length.out=5))
ar_rho <- c(-100, -5, -1, 0.1, 0.6, 0.99)
ar_rho <- c(-100, -10, -1, 0.05, 0.9)
ar_rho <- unique(ar_rho)
```

## Optimal binary Allocation (CRS)

This also works with any CRS CES.

```{r Optimal Linear Allocation Hard Code All Rho}
# Optimal Linear Equation

# Pull arrays out
ar_A <- tb_key_alpha_A_beta %>% pull(A)
ar_alpha <- tb_key_alpha_A_beta %>% pull(alpha)
ar_beta <- tb_key_alpha_A_beta %>% pull(beta)

# Define Function for each individual m, with hard coded arrays
ffi_binary_dplyrdo_func <- function(ls_row, fl_rho, bl_old=FALSE){
  # @param bl_old, weather to use old incorrect solution
  # hard coded inputs are:
  # 1, ar_A
  # 2, ar_alpha
  # 3, ar_beta
  # note follow https://fanwangecon.github.io/R4Econ/support/function/fs_applysapplymutate.html

  fl_alpha <- ls_row$alpha
  fl_A <- ls_row$A
  fl_beta <- ls_row$beta

  if (bl_old) {

    # the equation below is like doubly wrong I think, should be 1/(fl_rho-1)
    bl_old_wrong = TRUE
    if (bl_old_wrong) {
      ar_left <- ((ar_A + ar_alpha)/(fl_A + fl_alpha))
      ar_right <- ((ar_alpha*ar_beta)/(fl_alpha*fl_beta))^(1/(1-fl_rho))
      ar_full <- ar_left*ar_right
      ar_indicator <- (ar_full <= 1)
    } else {
      ar_left <- ((ar_A + ar_alpha)/(fl_A + fl_alpha))
      ar_right <- ((ar_alpha*ar_beta)/(fl_alpha*fl_beta))^(1/(fl_rho-1))
      ar_full <- ar_left*ar_right
      ar_indicator <- (ar_full <= 1)
    }

  } else {
      ar_left <- (
                  ((ar_A + ar_alpha)^fl_rho - (ar_A)^fl_rho)
                  /
                  ((fl_A + fl_alpha)^fl_rho - (fl_A)^fl_rho)
                 )
      ar_right <- ((ar_beta)/(fl_beta))
      ar_full <- ar_left*ar_right
      ar_indicator <- (ar_full >= 1)
  }

  it_rank <- sum(ar_indicator)
  return(it_rank)
}
ffi_binary_dplyrdo_func(tb_key_alpha_A_beta[1,], 0)


# accumulate allocation results
tb_opti_alloc_all_rho <- tb_key_alpha_A_beta

# A. First Loop over Planner Preference
# Generate Rank Order
for (it_rho_ctr in seq(1,length(ar_rho))) {
  rho = ar_rho[it_rho_ctr]

  queue_rank <- tb_key_alpha_A_beta %>% rowwise() %>%
                              do(rk = ffi_binary_dplyrdo_func(., rho)) %>%
                              unnest(rk) %>% pull(rk)

  tb_with_rank <- tb_key_alpha_A_beta %>% add_column(queue_rank)

  # m. Keep for df collection individual key + optimal allocation
  # _on stands for optimal nutritional choices
  # _eh stands for expected height
  tb_opti_allocate_wth_key <- tb_with_rank %>% select(one_of('Index','queue_rank')) %>%
                                rename(!!paste0('rho_c', it_rho_ctr, '_rk') := !!sym('queue_rank'))

  # n. merge optimal allocaiton results from different planner preference
  tb_opti_alloc_all_rho <- tb_opti_alloc_all_rho %>% left_join(tb_opti_allocate_wth_key, by='Index')
}

# o. print results
print(summary(tb_opti_alloc_all_rho))
str(tb_opti_alloc_all_rho)

# Make Longer
st_bisec_prefix <- 'rho_c'
svr_abfafb_long_name <- 'rho'
svr_bisect_iter <- 'nothing'
svr_number_col <- 'rank'
tb_opti_alloc_all_rho_long <- tb_opti_alloc_all_rho %>%
  pivot_longer(
    cols = starts_with(st_bisec_prefix),
    names_to = c(svr_abfafb_long_name, svr_bisect_iter),
    names_pattern = paste0(st_bisec_prefix, "(.*)_(.*)"),
    values_to = svr_number_col
  )
```

### Bump Plot for Optimal Binary Allocations

```{r binary allocation bump plot, fig.height = 10, fig.width = 10, fig.align = "center"}

tb_opti_alloc_all_rho_long %>%
  ggplot(aes(x = rho, y = rank, group = Index)) +
    geom_line(aes(color = race, alpha = 1), size = 2) +
    geom_point(aes(color = race, alpha = 1), size = 4) +
    scale_x_discrete(expand = c(0.85,0))+
    scale_y_reverse(breaks = 1:nrow(tb_opti_alloc_all_rho_long))+
    theme(legend.position = "none") +
    labs(x = "Equality vs Efficiency",
         y = "Rank",
         title = "Binary Deallocation Rank, Weight and Smokng") +
    ffy_opt_ghthm_dk() +
    geom_text(data =tb_opti_alloc_all_rho,aes(y=rho_c1_rk,x=0.6,label=Index),hjust="right")

```
